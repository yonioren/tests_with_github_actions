# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
    paths-ignore:
      - .github/workflows/test_selfhosted.yml
      - Helm/**
  #pull_request:
   # branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  Pre_reqs:
    runs-on: self-hosted
    steps:
      - name: set up dependency packages
        run: sudo apt update && sudo apt install unzip docker.io -y
        
      - name: checkout repo
        uses: actions/checkout@v4
        with:
          clean: false
  
  Testing:
    runs-on: self-hosted
    needs: [ Pre_reqs ]
    steps:
    
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Install dependencies
        working-directory: Python
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: pytest
        working-directory: Python/source

  Deploy_k8s:
    runs-on: self-hosted
    needs: [ Testing ]
    outputs: 
      MASTER_IP: ${{ steps.read_from_terraform.outputs.MASTER_IP }}
      PRV_KEY_PATH: ${{ steps.read_from_terraform.outputs.PRV_KEY_PATH }}
      MASTER_PRV_IP: ${{ steps.read_from_terraform.outputs.MASTER_PRV_IP }}
      URL: ${{ steps.read_from_terraform.outputs.URL }}
    steps:
      - name: init terraform
        run: terraform init
        working-directory: Terraform/k8s

      - name: run terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
        run: terraform apply -auto-approve
        working-directory: Terraform/k8s

      - name: read variables from terraform
        id: read_from_terraform
        working-directory: Terraform/k8s
        run: |
          MASTER_IP=$(terraform output -raw master_public_ip)
          echo "MASTER_IP=$MASTER_IP" >> $GITHUB_ENV
          echo "MASTER_IP=$MASTER_IP" >> $GITHUB_OUTPUT
          PRV_KEY_PATH=$(terraform output -raw private_key_path)
          echo "PRV_KEY_PATH=$PRV_KEY_PATH" >> $GITHUB_ENV
          echo "PRV_KEY_PATH=$PRV_KEY_PATH" >> $GITHUB_OUTPUT
          MASTER_PRV_IP=$(terraform output -raw master_private_ip)
          echo "MASTER_PRV_IP=$MASTER_PRV_IP" >> $GITHUB_ENV
          echo "MASTER_PRV_IP=$MASTER_PRV_IP" >> $GITHUB_OUTPUT
          echo "URL=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

      - name: write ansible playbook to server
        working-directory: Ansible
        run: |
          scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${PRV_KEY_PATH}" k8s.yaml "ubuntu@${MASTER_IP}:"

      - name: run ansible
        working-directory: Ansible
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${PRV_KEY_PATH}" "ubuntu@${MASTER_IP}" \
          "for ATTEMPT in {1..3}; do ansible all -m ping && break || false; done; exit $?"
          
          if [ "$?" -ne 0 ]
          then
            exit 1
          else
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${PRV_KEY_PATH}" "ubuntu@${MASTER_IP}" \
            "ansible-playbook /home/ubuntu/k8s.yaml"
          fi

  Build_and_release:
    runs-on: self-hosted
    needs: [ Deploy_k8s ]
    permissions:
      packages: write
    outputs: 
      CHART_URL: ${{ steps.chart_url.outputs.CHART_URL }}
    steps:
      - name: Log in to Docker Hub (root)
        run: |
          echo "${{ secrets.DOCKERHUB_PAT }}" | sudo docker login -u "${{ vars.DOCKERHUB_USERNAME }}" --password-stdin

      - name: Build and tag Docker image
        run: |
          DOCKER_IMAGE_NAME=${{vars.DOCKER_IMAGE_NAME}}
          VERSION=${{vars.VERSION}}
          DOCKERHUB_REPO=${{ vars.DOCKERHUB_USERNAME }}
          sudo docker build -t "${DOCKER_IMAGE_NAME}:${VERSION}" .
          sudo docker tag "${DOCKER_IMAGE_NAME}:${VERSION}" "${DOCKERHUB_REPO}/${DOCKER_IMAGE_NAME}:${VERSION}"
        working-directory: Python

      - name: Push Docker image
        run: |
          DOCKER_IMAGE_NAME=${{vars.DOCKER_IMAGE_NAME}}
          VERSION=${{vars.VERSION}}
          DOCKERHUB_REPO=${{ vars.DOCKERHUB_USERNAME }}
          sudo docker push "${DOCKERHUB_REPO}/${DOCKER_IMAGE_NAME}:${VERSION}"

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Build helm
        working-directory: Helm
        run: |
          export DOCKERHUB_REPO=${{ vars.DOCKERHUB_USERNAME }}
          export DOCKER_IMAGE_NAME=${{vars.DOCKER_IMAGE_NAME}}
          export VERSION=${{vars.VERSION}}
          export CHART_VERSION=${{vars.CHART_VERSION}}
          export NFS_SERVER=${{ needs.Deploy_k8s.outputs.MASTER_PRV_IP }}
          envsubst < values.yaml.tpl > projectplanner/values.yaml
          envsubst < Chart.yaml.tpl > projectplanner/Chart.yaml
          helm lint projectplanner
          helm package projectplanner --destination .

      - name: Push helm to github
        working-directory: Helm
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io --username ${{ github.actor }} --password-stdin
          helm push projectplanner-${{vars.CHART_VERSION}}.tgz oci://ghcr.io/${{ github.repository }}

      - name: share chart info
        id: chart_url
        run: |
          CHART_URL="oci://ghcr.io/${{ github.repository }}/projectplanner:${{vars.CHART_VERSION}}"
          echo "CHART_URL=$CHART_URL" >> $GITHUB_OUTPUT

  Deploy_version:
    runs-on: self-hosted
    needs: [ Deploy_k8s, Build_and_release ]
    steps:
      - name: deploy
        run: |
          CHART_URL="${{ needs.Build_and_release.outputs.CHART_URL }}"
          MASTER_IP=${{ needs.Deploy_k8s.outputs.MASTER_IP }}
          PRV_KEY_PATH=${{ needs.Deploy_k8s.outputs.PRV_KEY_PATH }}
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${PRV_KEY_PATH}" "ubuntu@${MASTER_IP}" "helm upgrade --install ${{vars.HELM_RELEASE_NAME}} ${CHART_URL}"

  OUTPUTS:
    runs-on: self-hosted
    needs: [ Deploy_version, Deploy_k8s ]
    steps:
      - name: OUTPUT
        run: echo "::notice title=Info Info::Surf to ${{needs.Deploy_k8s.outputs.URL}} to view page."

