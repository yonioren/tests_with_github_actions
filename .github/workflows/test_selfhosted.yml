# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
    paths-ignore:
      - .github/workflows/test_selfhosted.yml
      - K8S
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  Pre_reqs:
    runs-on: self-hosted
    steps:
      - name: set up dependency packages
        run: sudo apt update && sudo apt install unzip docker.io -y
        
      - name: checkout repo
        uses: actions/checkout@v4
        with:
          clean: false
  
  Testing:
    runs-on: self-hosted
    steps:
    
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Install dependencies
        working-directory: Python
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: pytest
        working-directory: Python/source

  Build_and_release:
    runs-on: self-hosted
    steps:
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and tag Docker image
        run: |
          DOCKER_IMAGE_NAME=${{vars.DOCKER_IMAGE_NAME}}
          VERSION=${{vars.VERSION}}
          DOCKERHUB_REPO=${{ secrets.DOCKER_USERNAME}}
          sudo docker build -t "${DOCKER_IMAGE_NAME}:${VERSION}" .
          sudo docker tag "${DOCKER_IMAGE_NAME}:${VERSION}" "${DOCKERHUB_REPO}/${DOCKER_IMAGE_NAME}:${VERSION}"
        working-directory: Python

      - name: Push Docker image
        run: |
          DOCKER_IMAGE_NAME=${{vars.DOCKER_IMAGE_NAME}}
          VERSION=${{vars.VERSION}}
          DOCKERHUB_REPO=${{ secrets.DOCKER_USERNAME}}
          docker push "${DOCKERHUB_REPO}/${DOCKER_IMAGE_NAME}:${VERSION}"

  Deploy_k8s:
    runs-on: self-hosted
    steps:
      - name: init terraform
        run: terraform init
        working-directory: Terraform/k8s

      - name: run terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
        run: terraform apply -auto-approve
        working-directory: Terraform/k8s

      - name: read variables from terraform
        id: read_from_terraform
        working-directory: Terraform/k8s
        run: |
          echo "MASTER_IP=$(terraform output -raw master_public_ip)" >> $GITHUB_ENV
          echo "PRV_KEY_PATH=$(terraform output -raw private_key_path)" >> $GITHUB_ENV

      - name: run ansible
        working-directory: Ansible
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${PRV_KEY_PATH}" "ubuntu@${MASTER_IP}" \
          "for ATTEMPT in {1..3}; do ansible all -m ping && break || false; done; exit $?"
          
          if [ "$?" -ne 0 ]
          then
            exit 1
          else
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${PRV_KEY_PATH}" "ubuntu@${MASTER_IP}" \
            "ansible-playbook /home/ubuntu/k8s.yaml"
          fi
